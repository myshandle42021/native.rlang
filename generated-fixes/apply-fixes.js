#!/usr/bin/env node
// apply-fixes.js - Automated fix application script
// Generated by ROL3 Auto-Debug System

const fs = require('fs').promises;
const path = require('path');

const FIXES = [
  {
    "id": "intent_fix_1",
    "title": "Intent Validation Enhancement",
    "description": "Improve intent validation logic",
    "file_path": "r/system/intent-detector.r",
    "fix_type": "code_change",
    "content": "# Review intent validation rules and confidence thresholds",
    "validation_steps": [
      "Test intent detection",
      "Check validation accuracy"
    ],
    "rollback_instructions": "Revert to previous intent detection logic",
    "confidence": 0.6,
    "priority": 1
  }
];

async function applyFix(fixId, interactive = false) {
  const fix = FIXES.find(f => f.id === fixId);
  if (!fix) {
    console.error(`❌ Fix ${fixId} not found`);
    return false;
  }

  console.log(`🔧 Applying fix: ${fix.title}`);
  console.log(`📁 Target file: ${fix.file_path}`);
  console.log(`⚡ Confidence: ${(fix.confidence * 100).toFixed(1)}%`);

  if (interactive) {
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const answer = await new Promise(resolve => {
      rl.question(`Apply this fix? (y/N): `, resolve);
    });
    rl.close();

    if (answer.toLowerCase() !== 'y') {
      console.log('⏭️ Skipped');
      return false;
    }
  }

  try {
    // Create backup if file exists
    if (fix.fix_type !== 'new_file') {
      try {
        const originalContent = await fs.readFile(fix.file_path, 'utf-8');
        const backupPath = `backups/${path.basename(fix.file_path)}_${Date.now()}.backup`;
        await fs.writeFile(backupPath, originalContent, 'utf-8');
        console.log(`💾 Backup created: ${backupPath}`);
      } catch (err) {
        console.warn(`⚠️ Could not create backup: ${err.message}`);
      }
    }

    // Apply the fix
    await fs.writeFile(fix.file_path, fix.content, 'utf-8');
    console.log(`✅ Applied: ${fix.title}`);

    // Run validation if possible
    console.log('🧪 Running validation...');
    for (const step of fix.validation_steps) {
      console.log(`   - ${step}`);
    }

    return true;

  } catch (error) {
    console.error(`💥 Failed to apply fix: ${error.message}`);
    return false;
  }
}

async function applySafeFixes() {
  const safeFixes = FIXES.filter(f =>
    f.confidence > 0.8 &&
    f.priority <= 2 &&
    ['config_change', 'documentation'].includes(f.fix_type)
  );

  console.log(`🛡️ Applying ${safeFixes.length} safe fixes...`);

  let applied = 0;
  for (const fix of safeFixes) {
    const success = await applyFix(fix.id, false);
    if (success) applied++;
  }

  console.log(`✅ Applied ${applied}/${safeFixes.length} safe fixes`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.includes('--help')) {
    console.log(`Usage:
  node apply-fixes.js --safe              Apply safe fixes only
  node apply-fixes.js --fix <id>          Apply specific fix
  node apply-fixes.js --interactive       Apply with prompts
  node apply-fixes.js --list              List all fixes`);
    return;
  }

  if (args.includes('--safe')) {
    await applySafeFixes();
  } else if (args.includes('--fix')) {
    const fixId = args[args.indexOf('--fix') + 1];
    await applyFix(fixId, args.includes('--interactive'));
  } else if (args.includes('--interactive')) {
    for (const fix of FIXES.sort((a, b) => a.priority - b.priority)) {
      await applyFix(fix.id, true);
    }
  } else if (args.includes('--list')) {
    console.log('Available fixes:');
    FIXES.forEach(f => {
      console.log(`  ${f.id}: ${f.title} (Priority: ${f.priority})`);
    });
  } else {
    console.log('Use --help for usage information');
  }
}

main().catch(console.error);
