// utils/rocketchat.ts - Auto-generated from universal template
// Generated by ROL3 service auto-generation system

import { authenticate, makeRequest } from "../templates/service-template";
import { RLangContext } from "../schema/types";

// Service-specific config (loaded from database/config)
const SERVICE_CONFIG = {
  service: "rocketchat",
  auth_type: "bearer" as const,
  base_url: process.env.ROCKETCHAT_URL || "https://your-rocketchat.com",
  endpoints: {
    send_message: "/api/v1/chat.postMessage",
    get_messages: "/api/v1/channels.messages",
    get_channels: "/api/v1/channels.list",
    create_webhook: "/api/v1/integrations.create",
    prompt_user: "/api/v1/chat.postMessage",
    upload_file: "/api/v1/rooms.upload",
    get_user_info: "/api/v1/users.info",
    create_direct_message: "/api/v1/im.create",
    get_channel_info: "/api/v1/channels.info",
    join_channel: "/api/v1/channels.join",
    leave_channel: "/api/v1/channels.leave",
    create_channel: "/api/v1/channels.create",
    delete_message: "/api/v1/chat.delete",
    update_message: "/api/v1/chat.update",
    react_to_message: "/api/v1/chat.react",
  },
  credentials: {
    token: process.env.ROCKETCHAT_AUTH_TOKEN,
    user_id: process.env.ROCKETCHAT_USER_ID,
    username: process.env.ROCKETCHAT_USERNAME,
  },
};

// Universal functions with RocketChat context
export async function authenticate(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";
  const serviceModule = await import("../templates/service-template");
  return serviceModule.authenticate(args, context);
}

// Enhanced sendMessage with RocketChat-specific formatting
export async function sendMessage(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  // Transform parameters to RocketChat format
  const rocketChatParams = {
    roomId: args.channel || args.to || args.roomId,
    text: args.text || args.message,
    attachments: formatAttachments(args.attachments),
    tmid: args.thread || args.reply_to,
    alias: args.alias || context.agentId,
    emoji: args.emoji,
    avatar: args.avatar,
  };

  // Remove undefined values
  Object.keys(rocketChatParams).forEach((key) => {
    if (rocketChatParams[key] === undefined) {
      delete rocketChatParams[key];
    }
  });

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "POST",
      "send_message",
      rocketChatParams,
      context,
    );

    return {
      success: result.success,
      message_id: result.message?._id,
      timestamp: result.message?.ts,
      channel: result.message?.rid,
      response: result,
    };
  } catch (error) {
    throw new Error(`RocketChat sendMessage failed: ${error.message}`);
  }
}

// Enhanced promptUser with RocketChat button support
export async function promptUser(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const attachments = [
    {
      title: args.title || "Please choose an option",
      text: args.text || args.message,
      color: args.color || "good",
      actions: formatButtons(args.buttons),
    },
  ];

  if (args.fields) {
    attachments[0].fields = args.fields;
  }

  return sendMessage(
    {
      channel: args.to || args.channel,
      text: args.message || " ",
      attachments: attachments,
    },
    context,
  );
}

// Get messages from a channel
export async function getMessages(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = {
    roomId: args.channel || args.roomId,
    count: args.limit || 50,
    oldest: args.since,
    latest: args.until,
    unreads: args.unreads_only,
    showThreadMessages: args.include_threads,
  };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "GET",
      "get_messages",
      params,
      context,
    );

    return {
      success: result.success,
      messages: result.messages?.map(formatMessage) || [],
      total: result.total,
      has_more: result.offset < result.total,
    };
  } catch (error) {
    throw new Error(`RocketChat getMessages failed: ${error.message}`);
  }
}

// Upload file to RocketChat
export async function uploadFile(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const formData = new FormData();
  formData.append("file", args.file);
  formData.append("roomId", args.channel || args.roomId);

  if (args.description) {
    formData.append("description", args.description);
  }
  if (args.message) {
    formData.append("msg", args.message);
  }

  try {
    const config = await getServiceConfig(context);
    const auth = await authenticate({}, context);

    const response = await fetch(
      config.base_url + config.endpoints.upload_file,
      {
        method: "POST",
        headers: auth,
        body: formData,
      },
    );

    if (!response.ok) {
      throw new Error(`Upload failed: ${response.statusText}`);
    }

    const result = await response.json();
    return {
      success: result.success,
      file_id: result.message?.file?._id,
      message_id: result.message?._id,
      url: result.message?.file?.url,
    };
  } catch (error) {
    throw new Error(`RocketChat uploadFile failed: ${error.message}`);
  }
}

// Create direct message channel
export async function createDM(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = {
    username: args.username || args.user,
  };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "POST",
      "create_direct_message",
      params,
      context,
    );

    return {
      success: result.success,
      room_id: result.room?.rid,
      room_name: result.room?.name,
    };
  } catch (error) {
    throw new Error(`RocketChat createDM failed: ${error.message}`);
  }
}

// Get user information
export async function getUserInfo(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = args.user_id
    ? { userId: args.user_id }
    : { username: args.username };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "GET",
      "get_user_info",
      params,
      context,
    );

    return {
      success: result.success,
      user: {
        id: result.user?._id,
        username: result.user?.username,
        name: result.user?.name,
        email: result.user?.emails?.[0]?.address,
        status: result.user?.status,
        avatar_url: result.user?.avatarUrl,
        timezone: result.user?.utcOffset,
      },
    };
  } catch (error) {
    throw new Error(`RocketChat getUserInfo failed: ${error.message}`);
  }
}

// React to a message
export async function reactToMessage(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = {
    messageId: args.message_id,
    emoji: args.emoji || args.reaction,
    shouldReact: args.should_react !== false,
  };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "POST",
      "react_to_message",
      params,
      context,
    );

    return {
      success: result.success,
      reaction_added: result.success,
    };
  } catch (error) {
    throw new Error(`RocketChat reactToMessage failed: ${error.message}`);
  }
}

// Delete message
export async function deleteMessage(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = {
    msgId: args.message_id,
    roomId: args.channel || args.room_id,
  };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "POST",
      "delete_message",
      params,
      context,
    );

    return {
      success: result.success,
      deleted: result.success,
    };
  } catch (error) {
    throw new Error(`RocketChat deleteMessage failed: ${error.message}`);
  }
}

// Update/edit message
export async function updateMessage(args: any, context: RLangContext) {
  context.memory.current_service = "rocketchat";

  const params = {
    msgId: args.message_id,
    roomId: args.channel || args.room_id,
    text: args.text || args.new_text,
  };

  try {
    const serviceModule = await import("../templates/service-template");
    const result = await serviceModule.makeRequest(
      "POST",
      "update_message",
      params,
      context,
    );

    return {
      success: result.success,
      updated: result.success,
      message: result.message,
    };
  } catch (error) {
    throw new Error(`RocketChat updateMessage failed: ${error.message}`);
  }
}

// Helper functions for RocketChat-specific formatting

function formatAttachments(attachments: any[]): any[] {
  if (!attachments || !Array.isArray(attachments)) {
    return [];
  }

  return attachments.map((attachment) => ({
    title: attachment.title,
    text: attachment.text,
    color: attachment.color || "good",
    fields: attachment.fields,
    actions: formatButtons(attachment.actions || attachment.buttons),
    image_url: attachment.image_url,
    thumb_url: attachment.thumb_url,
    author_name: attachment.author_name,
    author_link: attachment.author_link,
    author_icon: attachment.author_icon,
    title_link: attachment.title_link,
    footer: attachment.footer,
    footer_icon: attachment.footer_icon,
    ts: attachment.timestamp || attachment.ts,
  }));
}

function formatButtons(buttons: any[]): any[] {
  if (!buttons || !Array.isArray(buttons)) {
    return [];
  }

  return buttons.map((button) => {
    if (typeof button === "string") {
      return {
        type: "button",
        text: button,
        msg: button.toLowerCase().replace(/\s+/g, "_"),
        msg_in_chat_window: true,
        msg_processing_type: "respondWithMessage",
      };
    }

    return {
      type: "button",
      text: button.text || button.title || button.label,
      msg: button.value || button.action || button.text,
      msg_in_chat_window: true,
      msg_processing_type: "respondWithMessage",
      style: button.style || "default",
    };
  });
}

function formatMessage(message: any): any {
  return {
    id: message._id,
    text: message.msg,
    user: {
      id: message.u._id,
      username: message.u.username,
      name: message.u.name,
    },
    timestamp: message.ts,
    channel: message.rid,
    thread_id: message.tmid,
    edited: message.editedAt,
    reactions: message.reactions,
    attachments: message.attachments,
    mentions: message.mentions,
    channels: message.channels,
    starred: message.starred,
    pinned: message.pinned,
  };
}

// Get service configuration (used by service template)
async function getServiceConfig(context: RLangContext) {
  // This follows the service template pattern
  const { db } = await import("../utils/db");

  try {
    const { data } = await db
      .from("api_connections")
      .select("*")
      .eq("service", "rocketchat")
      .eq("client_id", context.clientId || "default")
      .limit(1);

    if (data && data.length > 0) {
      return data[0];
    }
  } catch (error) {
    console.warn("Failed to get RocketChat config from database:", error);
  }

  // Return default configuration
  return SERVICE_CONFIG;
}

// Dynamic aliases from service configuration
export const sendMsg = sendMessage;
export const postMessage = sendMessage;
export const prompt = promptUser;
export const getMsg = getMessages;
export const upload = uploadFile;
export const dm = createDM;
export const user = getUserInfo;
export const react = reactToMessage;
export const del = deleteMessage;
export const edit = updateMessage;
