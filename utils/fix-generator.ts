// utils/fix-generator.ts
// Code fix generation and file management system

import * as fs from "fs/promises";
import * as path from "path";
import { Fix } from "./claude-debug";

export interface AppliedFix {
  fix_id: string;
  applied_at: Date;
  original_content: string;
  backup_path: string;
  status: "applied" | "failed" | "rolled_back";
}

/**
 * Create fix files in the generated-fixes directory
 */
export async function createFixFiles(
  fixes: Fix[],
  outputDir: string = "./generated-fixes",
): Promise<void> {
  console.log(`üìÅ Creating fix files in ${outputDir}...`);

  try {
    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });

    // Create backup directory
    const backupDir = path.join(outputDir, "backups");
    await fs.mkdir(backupDir, { recursive: true });

    // Generate individual fix files
    for (const fix of fixes) {
      await createFixFile(fix, outputDir);
    }

    // Create summary README
    await createFixSummary(fixes, outputDir);

    // Create application script
    await createApplicationScript(fixes, outputDir);

    console.log(`‚úÖ Created ${fixes.length} fix files`);
  } catch (error) {
    console.error("üí• Failed to create fix files:", error);
    throw error;
  }
}

/**
 * Create individual fix file
 */
async function createFixFile(fix: Fix, outputDir: string): Promise<void> {
  const fileName = `${fix.id}_${sanitizeFileName(fix.title)}.md`;
  const filePath = path.join(outputDir, fileName);

  const content = `# Fix: ${fix.title}

**ID:** ${fix.id}
**Priority:** ${fix.priority}
**Confidence:** ${(fix.confidence * 100).toFixed(1)}%
**Type:** ${fix.fix_type}
**Target File:** ${fix.file_path}

## Description
${fix.description}

## Implementation

${fix.fix_type === "new_file" ? "### New File Content" : "### Code Changes"}

\`\`\`${getFileExtension(fix.file_path)}
${fix.content}
\`\`\`

## Validation Steps
${fix.validation_steps.map((step, i) => `${i + 1}. ${step}`).join("\n")}

## Rollback Instructions
${fix.rollback_instructions}

## Application Commands

### Manual Application
\`\`\`bash
# Review the fix first
cat ${fileName}

# Apply manually by copying content to ${fix.file_path}
\`\`\`

### Automated Application
\`\`\`bash
# Run the fix application script
npm run debug -- --apply-fix ${fix.id}
\`\`\`

---
*Generated by ROL3 Auto-Debug System on ${new Date().toISOString()}*
`;

  await fs.writeFile(filePath, content, "utf-8");
  console.log(`üìÑ Created fix file: ${fileName}`);
}

/**
 * Create summary README for all fixes
 */
async function createFixSummary(
  fixes: Fix[],
  outputDir: string,
): Promise<void> {
  const sortedFixes = fixes.sort((a, b) => a.priority - b.priority);

  const content = `# ROL3 System Fixes - ${new Date().toISOString()}

## Summary
Generated ${fixes.length} fixes for detected system issues.

## Quick Application Guide

### Priority Order (Apply in this order)
${sortedFixes
  .map((fix, i) => {
    const confidence = (fix.confidence * 100).toFixed(1);
    const risk =
      fix.priority <= 2
        ? "üü¢ Low"
        : fix.priority <= 4
          ? "üü° Medium"
          : "üî¥ High";
    return `${i + 1}. **${fix.title}** (${confidence}% confidence, ${risk} risk)
   - File: \`${fix.file_path}\`
   - Type: ${fix.fix_type}
   - See: \`${fix.id}_${sanitizeFileName(fix.title)}.md\``;
  })
  .join("\n\n")}

## Application Methods

### Method 1: Automated (Recommended for safe fixes)
\`\`\`bash
# Apply all safe fixes (>80% confidence, low risk)
npm run debug -- --apply-safe-fixes

# Apply specific fix
npm run debug -- --apply-fix ${sortedFixes[0]?.id}

# Apply with approval prompts
npm run debug -- --apply-fixes --interactive
\`\`\`

### Method 2: Manual Review and Application
1. Review each fix file in detail
2. Test changes in development environment
3. Apply fixes one by one with validation
4. Monitor system after each change

## Fix Categories

### High Priority (Apply First)
${sortedFixes
  .filter((f) => f.priority <= 2)
  .map((f) => `- ${f.title}`)
  .join("\n")}

### Medium Priority
${sortedFixes
  .filter((f) => f.priority > 2 && f.priority <= 4)
  .map((f) => `- ${f.title}`)
  .join("\n")}

### Low Priority
${sortedFixes
  .filter((f) => f.priority > 4)
  .map((f) => `- ${f.title}`)
  .join("\n")}

## File Types
${Object.entries(groupBy(fixes, "fix_type"))
  .map(([type, fixList]) => `- **${type}**: ${fixList.length} fixes`)
  .join("\n")}

## Safety Notes
- üü¢ **Safe to auto-apply**: Config changes, documentation updates
- üü° **Review before applying**: Code changes, new files
- üî¥ **Manual review required**: Database changes, core system modifications

## Rollback Plan
Each fix includes rollback instructions. Backups are created automatically in \`backups/\` directory.

---
*Auto-generated by ROL3 Auto-Debug System*
`;

  await fs.writeFile(path.join(outputDir, "README.md"), content, "utf-8");
  console.log("üìã Created fix summary: README.md");
}

/**
 * Create application script for automated fix deployment
 */
async function createApplicationScript(
  fixes: Fix[],
  outputDir: string,
): Promise<void> {
  const content = `#!/usr/bin/env node
// apply-fixes.js - Automated fix application script
// Generated by ROL3 Auto-Debug System

const fs = require('fs').promises;
const path = require('path');

const FIXES = ${JSON.stringify(fixes, null, 2)};

async function applyFix(fixId, interactive = false) {
  const fix = FIXES.find(f => f.id === fixId);
  if (!fix) {
    console.error(\`‚ùå Fix \${fixId} not found\`);
    return false;
  }

  console.log(\`üîß Applying fix: \${fix.title}\`);
  console.log(\`üìÅ Target file: \${fix.file_path}\`);
  console.log(\`‚ö° Confidence: \${(fix.confidence * 100).toFixed(1)}%\`);

  if (interactive) {
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const answer = await new Promise(resolve => {
      rl.question(\`Apply this fix? (y/N): \`, resolve);
    });
    rl.close();

    if (answer.toLowerCase() !== 'y') {
      console.log('‚è≠Ô∏è Skipped');
      return false;
    }
  }

  try {
    // Create backup if file exists
    if (fix.fix_type !== 'new_file') {
      try {
        const originalContent = await fs.readFile(fix.file_path, 'utf-8');
        const backupPath = \`backups/\${path.basename(fix.file_path)}_\${Date.now()}.backup\`;
        await fs.writeFile(backupPath, originalContent, 'utf-8');
        console.log(\`üíæ Backup created: \${backupPath}\`);
      } catch (err) {
        console.warn(\`‚ö†Ô∏è Could not create backup: \${err.message}\`);
      }
    }

    // Apply the fix
    await fs.writeFile(fix.file_path, fix.content, 'utf-8');
    console.log(\`‚úÖ Applied: \${fix.title}\`);

    // Run validation if possible
    console.log('üß™ Running validation...');
    for (const step of fix.validation_steps) {
      console.log(\`   - \${step}\`);
    }

    return true;

  } catch (error) {
    console.error(\`üí• Failed to apply fix: \${error.message}\`);
    return false;
  }
}

async function applySafeFixes() {
  const safeFixes = FIXES.filter(f =>
    f.confidence > 0.8 &&
    f.priority <= 2 &&
    ['config_change', 'documentation'].includes(f.fix_type)
  );

  console.log(\`üõ°Ô∏è Applying \${safeFixes.length} safe fixes...\`);

  let applied = 0;
  for (const fix of safeFixes) {
    const success = await applyFix(fix.id, false);
    if (success) applied++;
  }

  console.log(\`‚úÖ Applied \${applied}/\${safeFixes.length} safe fixes\`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.includes('--help')) {
    console.log(\`Usage:
  node apply-fixes.js --safe              Apply safe fixes only
  node apply-fixes.js --fix <id>          Apply specific fix
  node apply-fixes.js --interactive       Apply with prompts
  node apply-fixes.js --list              List all fixes\`);
    return;
  }

  if (args.includes('--safe')) {
    await applySafeFixes();
  } else if (args.includes('--fix')) {
    const fixId = args[args.indexOf('--fix') + 1];
    await applyFix(fixId, args.includes('--interactive'));
  } else if (args.includes('--interactive')) {
    for (const fix of FIXES.sort((a, b) => a.priority - b.priority)) {
      await applyFix(fix.id, true);
    }
  } else if (args.includes('--list')) {
    console.log('Available fixes:');
    FIXES.forEach(f => {
      console.log(\`  \${f.id}: \${f.title} (Priority: \${f.priority})\`);
    });
  } else {
    console.log('Use --help for usage information');
  }
}

main().catch(console.error);
`;

  const scriptPath = path.join(outputDir, "apply-fixes.js");
  await fs.writeFile(scriptPath, content, "utf-8");

  // Make executable
  try {
    await fs.chmod(scriptPath, 0o755);
  } catch (error) {
    // Ignore chmod errors on Windows
  }

  console.log("üöÄ Created application script: apply-fixes.js");
}

/**
 * Validate a fix before application
 */
export async function validateFix(fix: Fix): Promise<boolean> {
  console.log(`üß™ Validating fix: ${fix.title}`);

  try {
    // Check if target file/directory is writable
    if (fix.fix_type !== "new_file") {
      const targetDir = path.dirname(fix.file_path);
      try {
        await fs.access(targetDir, fs.constants.W_OK);
      } catch (error) {
        console.error(`‚ùå Target directory not writable: ${targetDir}`);
        return false;
      }
    }

    // Validate file content for basic syntax
    if (fix.file_path.endsWith(".ts") || fix.file_path.endsWith(".js")) {
      try {
        // Basic syntax validation - check for balanced braces
        const openBraces = (fix.content.match(/{/g) || []).length;
        const closeBraces = (fix.content.match(/}/g) || []).length;

        if (openBraces !== closeBraces) {
          console.error("‚ùå Unbalanced braces in fix content");
          return false;
        }
      } catch (error) {
        console.warn("‚ö†Ô∏è Could not validate syntax:", error);
      }
    }

    // Check confidence threshold
    if (fix.confidence < 0.6) {
      console.warn(
        `‚ö†Ô∏è Low confidence fix: ${(fix.confidence * 100).toFixed(1)}%`,
      );
      return false;
    }

    console.log(`‚úÖ Fix validation passed`);
    return true;
  } catch (error) {
    console.error(`üí• Fix validation failed:`, error);
    return false;
  }
}

/**
 * Apply a fix to the target file
 */
export async function applyFix(
  fix: Fix,
  autoApprove: boolean = false,
): Promise<AppliedFix> {
  console.log(`üîß Applying fix: ${fix.title}`);

  const appliedFix: AppliedFix = {
    fix_id: fix.id,
    applied_at: new Date(),
    original_content: "",
    backup_path: "",
    status: "failed",
  };

  try {
    // Validate fix first
    const isValid = await validateFix(fix);
    if (!isValid && !autoApprove) {
      throw new Error("Fix validation failed");
    }

    // Create backup if modifying existing file
    if (fix.fix_type !== "new_file") {
      try {
        const originalContent = await fs.readFile(fix.file_path, "utf-8");
        appliedFix.original_content = originalContent;

        const backupPath = `./generated-fixes/backups/${path.basename(fix.file_path)}_${Date.now()}.backup`;
        await fs.mkdir(path.dirname(backupPath), { recursive: true });
        await fs.writeFile(backupPath, originalContent, "utf-8");
        appliedFix.backup_path = backupPath;

        console.log(`üíæ Backup created: ${backupPath}`);
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not create backup: ${error}`);
      }
    }

    // Ensure target directory exists
    await fs.mkdir(path.dirname(fix.file_path), { recursive: true });

    // Apply the fix
    await fs.writeFile(fix.file_path, fix.content, "utf-8");
    appliedFix.status = "applied";

    console.log(`‚úÖ Applied fix: ${fix.title}`);
    console.log(`üìÅ Modified: ${fix.file_path}`);

    return appliedFix;
  } catch (error) {
    console.error(`üí• Failed to apply fix ${fix.id}:`, error);
    appliedFix.status = "failed";
    return appliedFix;
  }
}

/**
 * Rollback an applied fix
 */
export async function rollbackFix(appliedFix: AppliedFix): Promise<boolean> {
  console.log(`‚è™ Rolling back fix: ${appliedFix.fix_id}`);

  try {
    if (appliedFix.backup_path && appliedFix.original_content) {
      // Find the original file path from backup
      const backupFileName = path.basename(appliedFix.backup_path);
      const originalFileName = backupFileName.replace(/_\d+\.backup$/, "");

      // Restore from backup
      await fs.writeFile(
        originalFileName,
        appliedFix.original_content,
        "utf-8",
      );
      console.log(`‚úÖ Rollback successful`);
      return true;
    } else {
      console.error("‚ùå No backup available for rollback");
      return false;
    }
  } catch (error) {
    console.error("üí• Rollback failed:", error);
    return false;
  }
}

/**
 * Helper functions
 */
function sanitizeFileName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_|_$/g, "");
}

function getFileExtension(filePath: string): string {
  const ext = path.extname(filePath).slice(1);
  return ext || "text";
}

function groupBy<T>(array: T[], key: keyof T): Record<string, T[]> {
  return array.reduce((groups: Record<string, T[]>, item: T) => {
    const value = String(item[key]);
    groups[value] = groups[value] || [];
    groups[value].push(item);
    return groups;
  }, {});
}
